;add(1 4) = p[P{1 1} o[S P{2 3}]](1 4) ;user-friendly
;         = o[p[P{1 1} o[S P{2 3}]] C{1 0} C{4 0}]
;         = o[p[P{S(0) S(0)} o[S P{S(S(0)) S(S(S(0)))}]] C{S(0) 0} C{S(S(S(S(0)))) 0}] ;parser recognizes

(declaim (sb-ext:muffle-conditions cl:style-warning))
(load "parser.lisp")

(defparameter n (parse-integer (read-line)))

(defun flatten (l) ;thanks stackoverflow
  (cond ((null l) nil)
        ((atom l) (list l))
        (t (loop for a in l appending (flatten a)))))

(defun generate () ;generate all strings that can be generated by n production rules
  (primitive-recursion:parse (print (X))))

(defun V ()
  (concatenate 'string "o[p[C{0 0} o[" (A* n) " P{S(S(0)) S(S(0))}]] C{0 0}]"))

(defun A* (i)
  (if (= i 0)
    "S"
    (concatenate 'string "p[C{0 0} o[" (A* (1- i)) " P{S(S(0)) S(S(0))}]]")))

;n=2, 76111

(defun X () ;1 argument function
  ;(flatten (mapcar (lambda (a) (mapcar (lambda (x) (mapcar (lambda (y) (mapcar (lambda (z) (concatenate 'string "o[p[" z " " y "] " "C{" x " 0} C{" a " 0}]")) (A n 1))) (A n 3))) (N n))) (N n))))
  (flatten (mapcar (lambda (x) (mapcar (lambda (y) (mapcar (lambda (z) (concatenate 'string "o[p[" z " " y "] " "C{" x " 0}]")) (A n 0))) (A n 2))) (N n))))
  ;(flatten (mapcar (lambda (y) (mapcar (lambda (z) (concatenate 'string "o[p[" z " " y "] " "C{S(S(S(S(S(S(S(S(S(S(0)))))))))) 0}]")) (A n 0))) (A n 2))))
  ;(mapcar (lambda (z) (concatenate 'string "o[" z " C{S(S(S(S(S(S(S(S(S(S(0)))))))))) 0}]")) (flatten (R n 1))))
  ;(flatten (mapcar (lambda (x) (mapcar (lambda (y) (mapcar (lambda (z) (concatenate 'string "o[" z " " y " " x "]")) (A n -1))) (A n 2))) (N n))))
  ;(flatten (mapcar (lambda (x) (mapcar (lambda (y) (concatenate 'string "o[" y " " x "]")) (A n 1) (N n)))))) ;m=1, k=0

(defun A (i k) ;i = search depth, k = # args
  (if (= i 0)
    (if (= k 0)
      (flatten (append (C i k)))
      (if (= k 1)
        (flatten (append (C i k) (S i k) (P i k)))
        (flatten (append (C i k) (P i k)))))
    (if (= k 0)
      (flatten (append (O (1- i) k) (C i k)))
      (if (= k 1)
        (flatten (append (R (1- i) k) (O (1- i) k) (C i k) (S i k) (P i k)))
        (flatten (append (R (1- i) k) (O (1- i) k) (C i k) (P i k)))))))

(defun A* (i k)
  (if (= i 0)
    (A i k)
    (append (A* (1- i) k))))

(defun C (i k)
  (mapcar (lambda (x) (concatenate 'string "C{" x " " (N* k) "}")) (N i)))

(defun S (i k)
  (list "S"))

(defun P (i k)
  (mapcar (lambda (x) (concatenate 'string "P{" x " " (N* k) "}")) (N! (1- k))))

(defun O (i k) ;h is a 1 argument function, g = 1
  (mapcar (lambda (x) (mapcar (lambda (y) (concatenate 'string "o[" y " " x "]")) (A i 1))) (A i k)))
  ;(mapcar (lambda (x) (mapcar (lambda (y) (mapcar (lambda (z) (concatenate 'string "o[" z " " y x "]")) (A i 1))) (A i k))) (F i k m)))

(defun R (i k)
  ;(mapcar (lambda (x) (mapcar (lambda (y) (concatenate 'string "p[" y " " x "]")) (A i (1- k)))) (A i (1+ k))))
  (if (= i 0)
    (list (concatenate 'string "p[P{S(0) " (N* (1- k)) "} o[S P{S(S(0)) " (N* (1+ k)) "}]]"))
    (if (= k 1)
      (mapcar (lambda (y) (concatenate 'string "p[C{S(0) 0} " y "]")) (R (1- i) (1+ k)))
      (if (= k 2)
        (mapcar (lambda (y) (concatenate 'string "p[S " y "]")) (R (1- i) (1+ k)))
        (mapcar (lambda (y) (concatenate 'string "p[P{S(0) " (N* (1- k)) "} " y "]")) (R (1- i) (1+ k)))))))

(defun F (i k) ;add m arg later
  (if (= i n)
    (list "C{0 0}")
    (cons "" (apply #'append (mapcar (lambda (x) (mapcar (lambda (y) (concatenate 'string " " y x)) (A (1+ i)))) (F (1+ i) k))))))

(defun N (i)
  (if (= i 0)
    (list "0")
    (cons "0" (mapcar (lambda (N) (concatenate 'string "S(" N ")")) (N (1- i))))))

(defun N! (k)
  (if (= 0 k)
    (list "S(0)")
    (cons "S(0)" (mapcar (lambda (N) (concatenate 'string "S(" N ")")) (N! (1- k))))))

(defun N* (k)
  (if (= 0 k)
    "0"
    (concatenate 'string "S(" (N* (1- k)) ")")))

(generate)
